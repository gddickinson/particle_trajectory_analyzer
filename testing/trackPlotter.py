#!/usr/bin/env python3
"""
trajectory_viewer.py - GUI for viewing individual trajectory tracks with metrics

This script provides a graphical interface to view trajectory data from CSV files
generated by trajectory_analyzer.py. Features include:
- Display one track at a time with consistent scaling
- Navigate through tracks with Previous/Next buttons
- Display all calculated metrics for each track
- Color coding based on classification (mobile/immobile, linear/non-linear)
- Zoom and pan capabilities

Usage:
    python trajectory_viewer.py

Then use File > Open to load a CSV file with trajectory metrics.
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib.figure import Figure
import os
from pathlib import Path


class TrajectoryViewer:
    def __init__(self, root):
        self.root = root
        self.root.title("Trajectory Viewer")
        self.root.geometry("1200x800")

        # Data variables
        self.df = None
        self.track_numbers = []
        self.current_track_index = 0
        self.global_xlim = None
        self.global_ylim = None

        # Create GUI
        self.create_menu()
        self.create_widgets()

        # Bind keyboard shortcuts
        self.root.bind('<Left>', lambda e: self.previous_track())
        self.root.bind('<Right>', lambda e: self.next_track())
        self.root.bind('<Control-o>', lambda e: self.open_file())
        self.root.bind('<Control-q>', lambda e: self.root.quit())

    def create_menu(self):
        """Create the menu bar."""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="Open CSV...", command=self.open_file, accelerator="Ctrl+O")
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.root.quit, accelerator="Ctrl+Q")

        # View menu
        view_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="View", menu=view_menu)
        view_menu.add_command(label="Reset Zoom", command=self.reset_zoom)
        view_menu.add_command(label="Go to Track...", command=self.goto_track)

    def create_widgets(self):
        """Create the main GUI widgets."""
        # Main container
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=3)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(0, weight=1)

        # Left panel - Plot
        plot_frame = ttk.Frame(main_frame)
        plot_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 10))

        # Create matplotlib figure
        self.fig = Figure(figsize=(8, 6), dpi=100)
        self.ax = self.fig.add_subplot(111)
        self.ax.set_aspect('equal')
        self.ax.grid(True, alpha=0.3)

        # Create canvas
        self.canvas = FigureCanvasTkAgg(self.fig, master=plot_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)

        # Navigation toolbar
        toolbar = NavigationToolbar2Tk(self.canvas, plot_frame)
        toolbar.update()

        # Navigation buttons
        nav_frame = ttk.Frame(plot_frame)
        nav_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(10, 0))

        self.prev_button = ttk.Button(nav_frame, text="← Previous", command=self.previous_track)
        self.prev_button.pack(side=tk.LEFT, padx=5)

        self.track_label = ttk.Label(nav_frame, text="No data loaded", font=('Arial', 12))
        self.track_label.pack(side=tk.LEFT, expand=True)

        self.next_button = ttk.Button(nav_frame, text="Next →", command=self.next_track)
        self.next_button.pack(side=tk.RIGHT, padx=5)

        # Right panel - Metrics
        metrics_frame = ttk.LabelFrame(main_frame, text="Track Metrics", padding="10")
        metrics_frame.grid(row=0, column=1, sticky=(tk.W, tk.E, tk.N, tk.S))

        # Metrics text widget with scrollbar
        metrics_scroll = ttk.Scrollbar(metrics_frame, orient=tk.VERTICAL)
        self.metrics_text = tk.Text(metrics_frame, wrap=tk.WORD, width=40,
                                   yscrollcommand=metrics_scroll.set)
        metrics_scroll.config(command=self.metrics_text.yview)

        self.metrics_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        metrics_scroll.grid(row=0, column=1, sticky=(tk.N, tk.S))

        metrics_frame.columnconfigure(0, weight=1)
        metrics_frame.rowconfigure(0, weight=1)

        # Status bar
        self.status_bar = ttk.Label(self.root, text="Ready to load data", relief=tk.SUNKEN)
        self.status_bar.grid(row=1, column=0, sticky=(tk.W, tk.E))

        # Initial state
        self.prev_button.config(state='disabled')
        self.next_button.config(state='disabled')

    def open_file(self):
        """Open a CSV file with trajectory data."""
        filename = filedialog.askopenfilename(
            title="Select trajectory CSV file",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )

        if filename:
            try:
                # Load data
                self.df = pd.read_csv(filename)

                # Check for required columns
                required_cols = ['track_number', 'x', 'y']
                if not all(col in self.df.columns for col in required_cols):
                    messagebox.showerror("Error",
                        f"Missing required columns. File must contain: {', '.join(required_cols)}")
                    return

                # Get unique track numbers
                self.track_numbers = sorted(self.df['track_number'].unique())
                self.current_track_index = 0

                # Calculate global axis limits for consistent scaling
                margin = 0.1  # 10% margin
                x_range = self.df['x'].max() - self.df['x'].min()
                y_range = self.df['y'].max() - self.df['y'].min()

                self.global_xlim = (self.df['x'].min() - margin * x_range,
                                   self.df['x'].max() + margin * x_range)
                self.global_ylim = (self.df['y'].min() - margin * y_range,
                                   self.df['y'].max() + margin * y_range)

                # Enable navigation
                self.prev_button.config(state='normal')
                self.next_button.config(state='normal')

                # Update status
                self.status_bar.config(text=f"Loaded {len(self.track_numbers)} tracks from {os.path.basename(filename)}")

                # Display first track
                self.display_track()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load file:\n{str(e)}")

    def display_track(self):
        """Display the current track."""
        if self.df is None or not self.track_numbers:
            return

        # Get current track data
        track_num = self.track_numbers[self.current_track_index]
        track_data = self.df[self.df['track_number'] == track_num].sort_values('frame')

        # Clear previous plot
        self.ax.clear()

        # Determine color based on classification
        color = 'blue'  # Default color
        marker_size = 50

        # Check mobility classification
        if 'mobility_classification' in track_data.columns:
            mobility = track_data['mobility_classification'].iloc[0]
            if mobility == 'mobile':
                color = 'green'
            else:
                color = 'red'

        # Check linear classification for mobile tracks
        if 'linear_classification' in track_data.columns and color == 'green':
            linear_class = track_data['linear_classification'].iloc[0]
            if linear_class == 'linear_unidirectional':
                color = 'darkgreen'
            elif linear_class == 'linear_bidirectional':
                color = 'olive'
            elif linear_class == 'non_linear':
                color = 'orange'

        # Plot trajectory
        x = track_data['x'].values
        y = track_data['y'].values

        # Plot line
        self.ax.plot(x, y, color=color, linewidth=2, alpha=0.7)

        # Plot points
        self.ax.scatter(x, y, c=color, s=marker_size, alpha=0.5, edgecolors='black', linewidth=0.5)

        # Highlight start and end points
        self.ax.scatter(x[0], y[0], c='green', s=marker_size*2, marker='^',
                       edgecolors='black', linewidth=2, label='Start', zorder=5)
        self.ax.scatter(x[-1], y[-1], c='red', s=marker_size*2, marker='v',
                       edgecolors='black', linewidth=2, label='End', zorder=5)

        # Set consistent axis limits
        self.ax.set_xlim(self.global_xlim)
        self.ax.set_ylim(self.global_ylim)

        # Labels and title
        self.ax.set_xlabel('X Position')
        self.ax.set_ylabel('Y Position')
        self.ax.set_title(f'Track {track_num}')
        self.ax.legend(loc='upper right')
        self.ax.grid(True, alpha=0.3)

        # Update canvas
        self.canvas.draw()

        # Update navigation label
        self.track_label.config(text=f"Track {self.current_track_index + 1} of {len(self.track_numbers)}")

        # Update metrics display
        self.display_metrics(track_data)

        # Update button states
        self.prev_button.config(state='normal' if self.current_track_index > 0 else 'disabled')
        self.next_button.config(state='normal' if self.current_track_index < len(self.track_numbers) - 1 else 'disabled')

    def display_metrics(self, track_data):
        """Display metrics for the current track."""
        self.metrics_text.delete(1.0, tk.END)

        # Get first row (metrics are same for all rows of a track)
        metrics_row = track_data.iloc[0]
        track_num = metrics_row['track_number']

        # Build metrics text
        text_lines = [f"Track Number: {track_num}\n"]
        text_lines.append(f"Number of Points: {len(track_data)}\n")

        # Frame range
        text_lines.append(f"Frame Range: {track_data['frame'].min()} - {track_data['frame'].max()}\n")
        text_lines.append("-" * 30 + "\n")

        # Core metrics
        metric_groups = [
            ("Basic Metrics", ['rg', 'mean_step_length', 'sRg']),
            ("Classifications", ['mobility_classification', 'linear_classification']),
            ("Shape Metrics", ['asymmetry', 'skewness', 'kurtosis']),
            ("Linear Motion Metrics", ['eigenvalue_ratio', 'step_alignment', 'directionality_ratio']),
            ("Simple Method Metrics", ['mean_perpendicular_distance', 'normalized_perpendicular_distance'])
        ]

        for group_name, metrics in metric_groups:
            group_has_data = False
            group_text = []

            for metric in metrics:
                if metric in track_data.columns:
                    value = metrics_row[metric]
                    if pd.notna(value):
                        if isinstance(value, (int, float)):
                            if metric in ['sRg', 'rg', 'mean_step_length', 'mean_perpendicular_distance']:
                                group_text.append(f"{metric}: {value:.4f}")
                            elif metric in ['eigenvalue_ratio']:
                                group_text.append(f"{metric}: {value:.2f}")
                            else:
                                group_text.append(f"{metric}: {value:.6f}")
                        else:
                            group_text.append(f"{metric}: {value}")
                        group_has_data = True

            if group_has_data:
                text_lines.append(f"\n{group_name}:\n")
                for line in group_text:
                    text_lines.append(f"  {line}\n")

        # Insert text
        self.metrics_text.insert(1.0, ''.join(text_lines))

        # Apply color coding to classification text
        if 'mobility_classification' in track_data.columns:
            self.highlight_text('mobility_classification:', metrics_row['mobility_classification'])
        if 'linear_classification' in track_data.columns:
            self.highlight_text('linear_classification:', metrics_row['linear_classification'])

    def highlight_text(self, label, value):
        """Apply color highlighting to specific text in metrics display."""
        # Define colors for different classifications
        colors = {
            'mobile': 'green',
            'immobile': 'red',
            'linear_unidirectional': 'darkgreen',
            'linear_bidirectional': 'olive',
            'non_linear': 'orange'
        }

        # Search for the text and apply color
        start_idx = self.metrics_text.search(label, 1.0, tk.END)
        if start_idx:
            # Find the end of the line
            end_idx = self.metrics_text.search('\n', start_idx, tk.END)
            if end_idx:
                # Apply tag with color
                if value in colors:
                    tag_name = f"color_{value}"
                    self.metrics_text.tag_add(tag_name, start_idx, end_idx)
                    self.metrics_text.tag_config(tag_name, foreground=colors[value],
                                               font=('Arial', 10, 'bold'))

    def previous_track(self):
        """Go to previous track."""
        if self.current_track_index > 0:
            self.current_track_index -= 1
            self.display_track()

    def next_track(self):
        """Go to next track."""
        if self.current_track_index < len(self.track_numbers) - 1:
            self.current_track_index += 1
            self.display_track()

    def reset_zoom(self):
        """Reset zoom to show full extent."""
        if self.df is not None:
            self.ax.set_xlim(self.global_xlim)
            self.ax.set_ylim(self.global_ylim)
            self.canvas.draw()

    def goto_track(self):
        """Open dialog to go to specific track."""
        if not self.track_numbers:
            return

        # Create dialog
        dialog = tk.Toplevel(self.root)
        dialog.title("Go to Track")
        dialog.geometry("300x150")

        # Center the dialog
        dialog.transient(self.root)
        dialog.grab_set()

        # Create widgets
        ttk.Label(dialog, text="Enter track number:").pack(pady=10)

        # Entry with validation
        entry_var = tk.StringVar()
        entry = ttk.Entry(dialog, textvariable=entry_var)
        entry.pack(pady=5)
        entry.focus()

        # Status label
        status_label = ttk.Label(dialog, text="")
        status_label.pack(pady=5)

        def go_to():
            try:
                track_num = int(entry_var.get())
                if track_num in self.track_numbers:
                    self.current_track_index = self.track_numbers.index(track_num)
                    self.display_track()
                    dialog.destroy()
                else:
                    status_label.config(text=f"Track {track_num} not found", foreground='red')
            except ValueError:
                status_label.config(text="Please enter a valid number", foreground='red')

        # Buttons
        button_frame = ttk.Frame(dialog)
        button_frame.pack(pady=10)

        ttk.Button(button_frame, text="Go", command=go_to).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side=tk.LEFT, padx=5)

        # Bind Enter key
        entry.bind('<Return>', lambda e: go_to())


def main():
    root = tk.Tk()
    app = TrajectoryViewer(root)
    root.mainloop()


if __name__ == "__main__":
    main()
